<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>wow</title>
<style>
  html,body{height:100%;margin:0;background:#6ec6ff;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,'Helvetica Neue',Arial}
  #game{display:block;margin:0 auto;background:linear-gradient(#87CEEB,#7ec0ff);box-shadow:0 6px 24px rgba(0,0,0,0.25);}
  #ui{position:fixed;left:12px;bottom:12px;display:flex;gap:6px}
  .slot{width:48px;height:48px;border-radius:8px;background:rgba(255,255,255,0.12);backdrop-filter:blur(2px);display:flex;align-items:center;justify-content:center;border:2px solid rgba(0,0,0,0.15)}
  .slot.selected{outline:3px solid gold}
  #help{position:fixed;right:12px;bottom:12px;padding:8px 10px;background:rgba(0,0,0,0.35);color:#fff;border-radius:8px;font-size:13px}
  #title{position:fixed;left:12px;top:12px;color:#063; font-weight:700; text-shadow:0 1px 0 #fff7}
</style>
</head>
<body>
<canvas id="game" width="1280" height="720"></canvas>
<div id="title">Tiny Sandbox — sprites from <code>sprites/</code></div>
<div id="ui"></div>
<div id="help">Controls: A/D ←/→ move, Space jump, Mouse left-dig, right-place, 1-7 select block</div>
<script>
/*
  Tiny Terraria-like 2D sandbox (single-file)
  - Infinite horizontal terrain (procedural, deterministic)
  - Blocks: dirt, grass, stone, granite, diorite, copper_ore, tin_ore
  - Character sprite: sprites/character.png
  - Sprites folder: sprites/<name>.png (spaces replaced by _)
  - Host on GitHub Pages: include the "sprites" directory next to this HTML file.
*/

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let W = canvas.width, H = canvas.height;
const tileSize = 32; // pixels
const viewTilesX = Math.ceil(W / tileSize);
const viewTilesY = Math.ceil(H / tileSize) + 2;

const blockNames = [
  'dirt','grass','stone','granite','diorite','copper_ore','tin_ore'
];

const spriteCache = {};
function loadSprite(name){
  return new Promise(resolve => {
    const path = 'sprites/' + name + '.png';
    const img = new Image();
    img.src = path;
    img.onload = () => { spriteCache[name]=img; resolve(img); };
    img.onerror = ()=>{ spriteCache[name]=null; resolve(null); };
  });
}

// preload sprites (best-effort)
const toLoad = ['character',...blockNames.map(n=>n.replace(/ /g,'_'))];
Promise.all(toLoad.map(loadSprite)).then(()=>{
  // start after attempting to load
  init();
});

// --- Procedural world generation (1D value noise for height)
function hash32(n){
  n = Math.imul(n, 0x27d4eb2d);
  return (n ^ (n >>> 15)) >>> 0;
}
function randFrom(n){
  // returns 0..1
  return (hash32(n) % 1000000) / 1000000;
}
function smoothstep(t){ return t*t*(3-2*t); }
function valueNoise1D(x, seed=0){
  const xi = Math.floor(x);
  const xf = x - xi;
  const v1 = randFrom(xi+seed);
  const v2 = randFrom(xi+1+seed);
  const t = smoothstep(xf);
  return v1*(1-t) + v2*t;
}
function fractalNoise1D(x){
  // multiple octaves
  let total = 0; let amp = 1; let freq = 1; let maxA = 0;
  for(let o=0;o<5;o++){
    total += valueNoise1D(x*freq, 1000*o) * amp;
    maxA += amp; amp *= 0.5; freq *= 2;
  }
  return total / maxA;
}

// world parameters
const seaLevel = 80; // tile y coordinate for reference
const world = new Map(); // key: x (int) -> column array of tile names or null

function generateColumn(x){
  if(world.has(x)) return world.get(x);
  // generate height
  const n = fractalNoise1D(x/40);
  const n2 = fractalNoise1D(x/80);
  const height = Math.floor(seaLevel + n*18 + n2*36);
  const colHeight = 160; // maximum considered
  const col = new Array(colHeight).fill(null);
  for(let y=0;y<colHeight;y++){
    if(y > height){
      // air
      col[y]=null;
    } else if(y === height){
      col[y] = 'grass';
    } else if(y > height-5){
      col[y] = 'dirt';
    } else {
      // mostly stone with occasional granite/diorite
      let rock = 'stone';
      const r = randFrom(x*73856093 + y*19349663);
      if(r < 0.03) rock = 'granite';
      else if(r < 0.06) rock = 'diorite';
      // ores: copper and tin in veins, more common deeper
      const depth = height - y; // how deep below surface
      const oreRand = randFrom(x*1299827 + y*57885161);
      if(rock === 'stone'){
        if(depth > 8 && depth < 80 && oreRand < 0.015) rock = 'copper_ore';
        if(depth > 24 && depth < 120 && oreRand > 0.98) rock = 'tin_ore';
      }
      col[y] = rock;
    }
  }
  world.set(x, col);
  return col;
}

// player
const player = {
  x: 0.5, y: 100, vx:0, vy:0, width:0.8, height:1.6, onGround:false
};

// camera
const cam = {x: 0, y: 0};

// input
const keys = {};
window.addEventListener('keydown', e=>{ keys[e.key.toLowerCase()]=true; });
window.addEventListener('keyup', e=>{ keys[e.key.toLowerCase()]=false; });

// mouse
let mouse = {x:0,y:0,down:false,right:false};
canvas.addEventListener('mousemove', e=>{
  const r = canvas.getBoundingClientRect();
  mouse.x = (e.clientX - r.left);
  mouse.y = (e.clientY - r.top);
});
canvas.addEventListener('mousedown', e=>{
  if(e.button===0) mouse.down=true; if(e.button===2) mouse.right=true;
});
canvas.addEventListener('mouseup', e=>{ if(e.button===0) mouse.down=false; if(e.button===2) mouse.right=false; });
canvas.addEventListener('contextmenu', e=>e.preventDefault());

// world interactions: dig/place
function worldGet(x,y){
  const col = generateColumn(x);
  if(y<0 || y>=col.length) return null;
  return col[y];
}
function worldSet(x,y,name){
  const col = generateColumn(x);
  if(y<0 || y>=col.length) return false;
  col[y] = name;
  return true;
}

// mining: left click -> destroys block at mouse tile by setting to null
// placing: right click -> sets selected block
let selectedIndex = 0;
const hotbar = blockNames; // same order

// UI hotbar
const ui = document.getElementById('ui');
function rebuildHotbar(){
  ui.innerHTML='';
  for(let i=0;i<hotbar.length;i++){
    const s = document.createElement('div');
    s.className='slot'+(i===selectedIndex? ' selected':'');
    s.title = (i+1) + ' — ' + hotbar[i];
    const img = document.createElement('img');
    img.style.width='28px'; img.style.height='28px';
    const name = hotbar[i].replace(/ /g,'_');
    img.src = 'sprites/'+name+'.png';
    img.onerror = ()=>{ img.style.display='none'; s.textContent = (i+1); };
    s.appendChild(img);
    ui.appendChild(s);
  }
}
rebuildHotbar();
window.addEventListener('keydown', e=>{
  if(e.key>='1' && e.key<='9'){
    const idx = parseInt(e.key)-1;
    if(idx < hotbar.length){ selectedIndex = idx; rebuildHotbar(); }
  }
});

// gameplay constants
const GRAV = 0.45; const FRICTION = 0.85; const MAX_FALL = 12;

function update(dt){
  // horizontal movement
  const speed = 6;
  let move = 0;
  if(keys['a'] || keys['arrowleft']) move -= 1;
  if(keys['d'] || keys['arrowright']) move += 1;
  player.vx += move * 0.5;
  player.vx *= 0.9;
  if(Math.abs(player.vx) > speed) player.vx = Math.sign(player.vx)*speed;

  // jump
  if((keys[' '] || keys['w'] || keys['arrowup']) && player.onGround){ player.vy = -10; player.onGround=false; }

  // gravity
  player.vy += GRAV; if(player.vy > MAX_FALL) player.vy = MAX_FALL;

  // apply movement with simple tile collision
  // predict horizontal
  let nx = player.x + player.vx * dt;
  if(!collides(nx, player.y)) player.x = nx; else player.vx = 0;
  // predict vertical
  let ny = player.y + player.vy * dt;
  if(!collides(player.x, ny)){
    player.y = ny; player.onGround=false;
  } else {
    // collided vertically
    if(player.vy > 0){ // landing
      player.onGround = true;
    }
    player.vy = 0;
  }

  // camera follow
  cam.x = player.x * tileSize - W/2 + (player.width*tileSize)/2;
  cam.y = player.y * tileSize - H/2 + (player.height*tileSize)/2;

  // mouse interactions
  handleMouseActions();
}

function collides(px, py){
  // check 4 corners of player's bbox against solid tiles
  const left = px - player.width/2; const right = px + player.width/2;
  const top = py - player.height; const bottom = py;
  for(let tx=Math.floor(left); tx<=Math.floor(right-1e-9); tx++){
    for(let ty=Math.floor(top); ty<=Math.floor(bottom-1e-9); ty++){
      const t = worldGet(tx, ty);
      if(t !== null){
        return true;
      }
    }
  }
  return false;
}

let lastMouseAction = 0;
function handleMouseActions(){
  const mx = Math.floor((mouse.x + cam.x)/tileSize);
  const my = Math.floor((mouse.y + cam.y)/tileSize);
  const now = performance.now();
  if(mouse.down && now - lastMouseAction > 120){
    // dig
    const block = worldGet(mx,my);
    if(block !== null){ worldSet(mx,my,null); }
    lastMouseAction = now;
  }
  if(mouse.right && now - lastMouseAction > 120){
    // place selected block if empty and not inside player
    const block = worldGet(mx,my);
    if(block === null){
      const name = hotbar[selectedIndex];
      // prevent placing where player stands; simple check
      const px = Math.floor(player.x); const py = Math.floor(player.y);
      if(!(mx>=px-1 && mx<=px+1 && my>=py-2 && my<=py)){
        worldSet(mx,my,name);
      }
    }
    lastMouseAction = now;
  }
}

// rendering
function draw(){
  // clear
  ctx.clearRect(0,0,W,H);

  // sky gradient
  const g = ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0,'#7ec0ff'); g.addColorStop(1,'#8fd7ff');
  ctx.fillStyle = g; ctx.fillRect(0,0,W,H);

  // compute visible tile range
  const startX = Math.floor(cam.x / tileSize) - 2;
  const endX = Math.ceil((cam.x + W) / tileSize) + 2;
  const startY = Math.floor(cam.y / tileSize) - 2;
  const endY = Math.ceil((cam.y + H) / tileSize) + 2;

  // draw tiles
  for(let tx = startX; tx <= endX; tx++){
    const col = generateColumn(tx);
    for(let ty = startY; ty <= endY; ty++){
      const tile = (ty>=0 && ty<col.length) ? col[ty] : null;
      if(tile === null) continue;
      const sx = tx*tileSize - cam.x;
      const sy = ty*tileSize - cam.y;
      drawTile(tile, sx, sy);
    }
  }

  // draw grid lightly (optional)
  // player
  const charImg = spriteCache['character'];
  const px = player.x*tileSize - cam.x - (player.width*tileSize)/2;
  const py = player.y*tileSize - cam.y - player.height*tileSize;
  if(charImg){
    ctx.drawImage(charImg, px, py, player.width*tileSize, player.height*tileSize);
  } else {
    // fallback
    ctx.fillStyle = '#ff7f50'; ctx.fillRect(px, py, player.width*tileSize, player.height*tileSize);
  }

  // mouse highlight
  const mtx = Math.floor((mouse.x + cam.x)/tileSize);
  const mty = Math.floor((mouse.y + cam.y)/tileSize);
  const hx = mtx*tileSize - cam.x;
  const hy = mty*tileSize - cam.y;
  ctx.strokeStyle = 'rgba(255,255,255,0.9)'; ctx.lineWidth=2;
  ctx.strokeRect(hx+1, hy+1, tileSize-2, tileSize-2);
}

function drawTile(name, sx, sy){
  const img = spriteCache[name];
  if(img){ ctx.drawImage(img, sx, sy, tileSize, tileSize); }
  else {
    // fallback color for each type
    const colorMap = {
      'dirt':'#7b4f2a','grass':'#4caf50','stone':'#8b8b8b','granite':'#9e7f7f','diorite':'#cfcfcf','copper_ore':'#b87333','tin_ore':'#c0c0ff'
    };
    ctx.fillStyle = colorMap[name]||'#f0f'; ctx.fillRect(sx, sy, tileSize, tileSize);
    ctx.strokeStyle = 'rgba(0,0,0,0.08)'; ctx.strokeRect(sx+0.5, sy+0.5, tileSize-1, tileSize-1);
  }
}

// main loop
let last = performance.now();
function loop(now){
  const dt = Math.min(60,(now-last))/16; last = now;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}

function init(){
  // ensure some columns around 0
  for(let x=-200;x<=200;x++) generateColumn(x);
  // place player on surface at x=0
  const col0 = generateColumn(0);
  let spawnY = 0; for(let y=0;y<col0.length;y++) if(col0[y] !== null){ spawnY = y-0.01; break; }
  player.x = 0.5; player.y = spawnY;

  last = performance.now();
  requestAnimationFrame(loop);
}

// handle resizing
window.addEventListener('resize', ()=>{
  const ratio = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  // keep fixed size but scale for crispness
});

// nice small helpers: move camera when window clicked? none.

// instructions to user in console
console.log('Tiny sandbox loaded. Place this HTML and a sprites folder (sprites/<name>.png) on your GitHub Pages site.');
console.log('Block sprite names expected:', toLoad.join(', '));
</script>
</body>
</html>
